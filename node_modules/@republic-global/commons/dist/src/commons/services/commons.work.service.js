import { OpenAPI, postWorkDetailsList, } from '@republic-global/work-client';
import { commonsConfig } from '../commons-config.js';
import { authHeaderInjector, headerInjector } from '../middleware/index.js';
import { LoggerFactory } from '../utils/index.js';
import { CacheService } from './cache.service.js';
import { SharedCacheKeys } from './shared-cache-keys.js';
const workConfig = commonsConfig.services.work;
export class CommonsWorkService {
    cacheService;
    logger = LoggerFactory.getLogger('CommonsWorkService');
    constructor(cacheService) {
        this.cacheService = cacheService;
        OpenAPI.BASE = workConfig.baseUrl;
        OpenAPI.interceptors.request.use(authHeaderInjector);
        OpenAPI.interceptors.request.use(headerInjector);
    }
    async getWorkDetails(workIds) {
        this.logger.debug(`Getting details for workIds: ${workIds}`);
        if (!workIds.length) {
            return [];
        }
        // Retrieving work from cache
        const cachedWork = await this.cacheService.getHashFieldValues(SharedCacheKeys.workRecordsHash, workIds);
        // Filter out workIds that were not found in the cache
        // Redis returns values in the same order they were requested
        const missingWorkIds = workIds.filter((_id, index) => cachedWork[index] === null);
        const missingWorkDetails = await this.retrieveWorkDetailsAndCache(missingWorkIds);
        // Concatenating cached work and missing work
        return cachedWork
            .filter((buffer) => buffer !== null)
            .map((buffer) => JSON.parse(buffer.toString()))
            .concat(missingWorkDetails);
    }
    async retrieveWorkDetailsAndCache(workIds) {
        if (workIds.length) {
            this.logger.debug(`Retrieving work details from work service: ${workIds}`);
            // Retrieving from service
            const retrievedWork = await postWorkDetailsList({
                requestBody: { workIds: workIds },
            });
            // Save to cache
            if (retrievedWork.workDetailsList &&
                retrievedWork.workDetailsList.length) {
                const workDetailsMap = new Map(retrievedWork.workDetailsList.map((work) => [
                    work.workId,
                    Buffer.from(JSON.stringify(work)),
                ]));
                await this.cacheService.setHashFieldValues(SharedCacheKeys.workRecordsHash, workDetailsMap);
                return retrievedWork.workDetailsList;
            }
        }
        return [];
    }
}
//# sourceMappingURL=commons.work.service.js.map