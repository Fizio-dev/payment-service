import { Redis } from 'ioredis';
import {} from 'tsyringe';
import { commonsConfig } from '../commons-config.js';
import { LoggerFactory } from '../utils/index.js';
const redisConfig = commonsConfig.redis.config;
const redisOpts = commonsConfig.redis.opts;
const generateKey = (cacheKey) => {
    const { keyName, identifier } = cacheKey;
    const rootNamespace = isSharedCacheKey(cacheKey)
        ? cacheKey.rootNamespace
        : commonsConfig.serviceName;
    const suffix = identifier ? `:${identifier}` : '';
    return `${rootNamespace}:${keyName}${suffix}`;
};
const isSharedCacheKey = (cacheKey) => {
    return cacheKey.rootNamespace !== undefined;
};
export class CacheService {
    static MAX = '+inf';
    static MIN = '-inf';
    logger = LoggerFactory.getLogger(CacheService.name);
    client;
    constructor() {
        this.logger.info(`Initializing redis connection host: ${redisConfig.host}, port: ${redisConfig.port}, db: ${redisConfig.db}`);
        // @ts-expect-error intentional - making password optional
        this.client = new Redis({
            ...redisConfig,
        });
    }
    async set(key, value, opts, commander) {
        try {
            await (commander ?? this.client).set(generateKey(key), value, 'EX', opts?.ttl ?? redisOpts.ttl);
        }
        catch (error) {
            this.logger.error('Error setting value in Redis:', error);
            throw error;
        }
    }
    async get(key, commander) {
        try {
            const cacheKey = generateKey(key);
            if (commander) {
                commander.getBuffer(cacheKey);
                return null;
            }
            else {
                return await this.client.getBuffer(cacheKey);
            }
        }
        catch (error) {
            this.logger.error('Error getting value from Redis:', error);
            throw error;
        }
    }
    async del(key) {
        try {
            return await this.client.del(generateKey(key));
        }
        catch (error) {
            this.logger.error('Error deleting key from Redis:', error);
            throw error;
        }
    }
    async setHashFieldValue(cacheKey, field, value, opts, commander) {
        try {
            const key = generateKey(cacheKey);
            await (commander ?? this.client).hset(key, field, value);
            await (commander ?? this.client).expire(key, opts?.ttl ?? redisOpts.ttl);
        }
        catch (error) {
            this.logger.error('Error setting hash field in Redis:', error);
            throw error;
        }
    }
    async getHashFieldValue(key, field, commander) {
        try {
            const cacheKey = generateKey(key);
            if (commander) {
                commander.hgetBuffer(cacheKey, field);
                return null;
            }
            return await this.client.hgetBuffer(cacheKey, field);
        }
        catch (error) {
            this.logger.error('Error getting hash field from Redis:', error);
            throw error;
        }
    }
    async setHashFieldValues(cacheKey, data, opts, commander) {
        try {
            const key = generateKey(cacheKey);
            await (commander ?? this.client).hset(key, data);
            await (commander ?? this.client).expire(key, opts?.ttl ?? redisOpts.ttl);
        }
        catch (error) {
            this.logger.error('Error setting hash field in Redis:', error);
            throw error;
        }
    }
    async getHashFieldValues(key, fields, commander) {
        try {
            const cacheKey = generateKey(key);
            if (commander) {
                commander.hmgetBuffer(cacheKey, ...fields);
                return [];
            }
            return await this.client.hmgetBuffer(cacheKey, ...fields);
        }
        catch (error) {
            this.logger.error('Error getting hash field from Redis:', error);
            throw error;
        }
    }
    async addToSet(cacheKey, member, opts, commander) {
        try {
            const key = generateKey(cacheKey);
            await (commander ?? this.client).sadd(key, member);
            await (commander ?? this.client).expire(key, opts?.ttl ?? redisOpts.ttl);
        }
        catch (error) {
            this.logger.error('Error calling sadd/expire:', error);
            throw error;
        }
    }
    async removeFromSet(key, member, commander) {
        try {
            await (commander ?? this.client).srem(generateKey(key), member);
        }
        catch (error) {
            this.logger.error('Error calling srem:', error);
            throw error;
        }
    }
    async isMemberOfSet(key, member, commander) {
        try {
            const cacheKey = generateKey(key);
            if (commander) {
                commander.sismember(cacheKey, member);
            }
            else {
                const isMember = await this.client.sismember(cacheKey, member);
                return isMember === 1;
            }
        }
        catch (error) {
            this.logger.error('Error calling smismember:', error);
            throw error;
        }
    }
    async areMembersOfSet(key, members, commander) {
        try {
            const cacheKey = generateKey(key);
            if (commander) {
                commander.smismember(cacheKey, members);
            }
            else {
                const results = await this.client.smismember(cacheKey, members);
                return results.map((result) => result === 1);
            }
        }
        catch (error) {
            this.logger.error('Error calling smismember:', error);
            throw error;
        }
    }
    async getAllSetMembers(key, commander) {
        try {
            const cacheKey = generateKey(key);
            if (commander) {
                commander.smembers(cacheKey);
            }
            else {
                return await this.client.smembers(cacheKey);
            }
        }
        catch (error) {
            this.logger.error('Error calling smembers:', error);
            throw error;
        }
    }
    async countSetMembers(key, commander) {
        try {
            const cacheKey = generateKey(key);
            if (commander) {
                commander.scard(cacheKey);
            }
            else {
                return await this.client.scard(cacheKey);
            }
        }
        catch (error) {
            this.logger.error('Error calling scard:', error);
            throw error;
        }
    }
    async addToSortedSet(key, member, score, opts, commander) {
        try {
            await (commander ?? this.client).zadd(generateKey(key), score ?? Date.now() + (opts?.ttl ?? redisOpts.ttl), member);
        }
        catch (error) {
            this.logger.error('Error calling zadd:', error);
            throw error;
        }
    }
    async removeFromSortedSet(key, member, commander) {
        try {
            await (commander ?? this.client).zrem(generateKey(key), member);
        }
        catch (error) {
            this.logger.error('Error calling zrem:', error);
            throw error;
        }
    }
    async removeFromSortedSetWithScoreBetween(key, min, max, commander) {
        try {
            await (commander ?? this.client).zremrangebyscore(generateKey(key), min, max);
        }
        catch (error) {
            this.logger.error('Error calling zremrangebyscore:', error);
            throw error;
        }
    }
    async countElementsInSortedSetWithScoreBetween(key, min, max, commander) {
        try {
            const cacheKey = generateKey(key);
            if (commander) {
                commander.zcount(cacheKey, min, max);
            }
            else {
                return await this.client.zcount(cacheKey, min, max);
            }
        }
        catch (error) {
            this.logger.error('Error calling zcount:', error);
            throw error;
        }
    }
    async multi(fn) {
        const commander = this.client.pipeline();
        fn(commander);
        return commander.exec();
    }
    async dispose() {
        this.logger.info('disposing redis connection...');
        try {
            await this.client.quit();
        }
        catch (error) {
            this.logger.error('Error quitting Redis connection:', error);
            throw error;
        }
    }
}
//# sourceMappingURL=cache.service.js.map