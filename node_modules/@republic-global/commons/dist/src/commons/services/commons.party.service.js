import { OpenAPI, getPartyById, postPartyCraftspersonList, postPartyPartyList, } from '@republic-global/party-client';
import { commonsConfig } from '../commons-config.js';
import { headerInjector, serviceAccountAuthHeaderInjector, } from '../middleware/index.js';
import { LoggerFactory } from '../utils/index.js';
import { CacheService } from './cache.service.js';
import { SharedCacheKeys } from './shared-cache-keys.js';
const partyConfig = commonsConfig.services.party;
export class CommonsPartyService {
    cacheService;
    logger = LoggerFactory.getLogger('CommonsPartyService');
    constructor(cacheService) {
        this.cacheService = cacheService;
        OpenAPI.BASE = partyConfig.baseUrl;
        OpenAPI.interceptors.request.use(serviceAccountAuthHeaderInjector);
        OpenAPI.interceptors.request.use(headerInjector);
    }
    async getCraftspeopleDetails(craftspersonCcIds) {
        this.logger.info(`Getting details for craftspeople with ids ${craftspersonCcIds}`);
        if (!craftspersonCcIds.length) {
            return [];
        }
        const cachedCraftspeople = await this.cacheService.getHashFieldValues(SharedCacheKeys.craftspeopleRecordsHash, craftspersonCcIds);
        // Filtering out ccId that were not found in the cache
        // Redis returns values in the same order they were requested
        const missingCcIds = craftspersonCcIds.filter((_id, index) => cachedCraftspeople[index] === null);
        const missingCraftspeople = await this.retrieveCraftspeopleAndCache(missingCcIds);
        // Concatenating cached and retrieved craftspeople
        return cachedCraftspeople
            .filter((buffer) => buffer !== null)
            .map((buffer) => JSON.parse(buffer.toString()))
            .concat(missingCraftspeople);
    }
    async getParty(partyCcId) {
        const partyBuffer = await this.cacheService.getHashFieldValue(SharedCacheKeys.partyRecordsHash, partyCcId);
        let party;
        if (partyBuffer) {
            party = JSON.parse(partyBuffer.toString());
        }
        else {
            party = await getPartyById({ id: partyCcId });
            await this.cacheService.setHashFieldValue(SharedCacheKeys.partyRecordsHash, partyCcId, Buffer.from(JSON.stringify(party)));
        }
        return party;
    }
    async retrieveParties(ccIds) {
        this.logger.debug(`Retrieving parties for ccIds: ${ccIds}`);
        if (ccIds.length) {
            const cachedParties = await this.cacheService.getHashFieldValues(SharedCacheKeys.partyRecordsHash, ccIds);
            // Filtering out ccId that were not found in the cache
            // Redis returns values in the same order they were requested
            const missingCcIds = ccIds.filter((_id, index) => cachedParties[index] === null);
            const missingParties = await this.retrievePartiesAndCache(missingCcIds);
            this.logger.debug(`Retrieved missing parties ${missingParties.length}`);
            // Concatenating cached and retrieved craftspeople
            const allParties = cachedParties
                .filter((buffer) => buffer !== null)
                .map((buffer) => JSON.parse(buffer.toString()))
                .concat(missingParties);
            this.logger.debug(`Final party response: ${allParties.length}`);
            return allParties;
        }
        return [];
    }
    async retrievePartiesAndCache(ccIds) {
        if (ccIds.length) {
            this.logger.debug(`Retrieving parties ${ccIds} from party service`);
            // Retrieve from service
            const partyResponse = await postPartyPartyList({
                requestBody: { ccIds: ccIds },
            });
            this.logger.debug(`Response from party service: ${JSON.stringify(partyResponse)}`);
            // Save to cache
            if (partyResponse?.length) {
                await this.cacheService.setHashFieldValues(SharedCacheKeys.partyRecordsHash, new Map(partyResponse.map((party) => [
                    party.ccId,
                    Buffer.from(JSON.stringify(party)),
                ])));
                return partyResponse;
            }
        }
        return [];
    }
    async retrieveCraftspeopleAndCache(ccIds) {
        if (ccIds.length) {
            const body = {
                requestBody: {
                    ccIds: ccIds,
                },
            };
            // Retrieve from service
            const craftspeopleResponse = await postPartyCraftspersonList(body);
            // Save to cache
            if (craftspeopleResponse.records &&
                craftspeopleResponse.records.length) {
                await this.cacheService.setHashFieldValues(SharedCacheKeys.craftspeopleRecordsHash, new Map(craftspeopleResponse.records.map((craftsperson) => [
                    // @ts-expect-error party service returns ccId in id field as of now TODO
                    craftsperson.ccId ?? craftsperson.id,
                    Buffer.from(JSON.stringify(craftsperson)),
                ])));
                return craftspeopleResponse.records;
            }
        }
        return [];
    }
}
//# sourceMappingURL=commons.party.service.js.map