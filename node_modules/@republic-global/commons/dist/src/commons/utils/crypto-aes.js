// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
import crypto from 'crypto';
import { commonsConfig } from '../commons-config.js';
const CRYPTO_IMPL_VERSION = 1;
const CRYPTO_ALGORITHM = 'aes-256-gcm';
const DEKS = commonsConfig.dekList.split(',');
const DEKS_MAP = {};
DEKS.forEach((dek) => {
    DEKS_MAP[getKid(dek)] = dek;
});
function encryptAes(input, iv, base64Key) {
    const key = Buffer.from(base64Key, 'base64');
    iv = Buffer.from(iv, 'base64');
    const buffer = Buffer.from(input);
    const cipher = crypto.createCipheriv(CRYPTO_ALGORITHM, key, iv);
    let encrypted = cipher.update(buffer, 'Buffer', 'base64');
    encrypted += cipher.final('base64');
    return {
        ciphertext: encrypted,
        tag: cipher.getAuthTag().toString('base64'),
    };
}
function decryptAes(ciphertext, iv64, base64Key, tag) {
    const key = Buffer.from(base64Key, 'base64');
    const iv = Buffer.from(iv64, 'base64');
    const decipher = crypto.createDecipheriv(CRYPTO_ALGORITHM, key, iv);
    decipher.setAuthTag(Buffer.from(tag, 'base64'));
    let decrypted = decipher.update(Buffer.from(ciphertext, 'base64'));
    decrypted += decipher.final();
    return decrypted;
}
function getKid(dek256Base64) {
    const halfByteskey = Buffer.from(dek256Base64, 'base64').subarray(0, 16);
    return crypto
        .createHash('sha256')
        .update(halfByteskey, 'utf8')
        .digest('base64');
}
function decrypt(internalCiphertext) {
    if (!internalCiphertext) {
        return internalCiphertext;
    }
    const ict = JSON.parse(internalCiphertext);
    if (!DEKS_MAP) {
        throw new Error('DEKS_MAP_NULL');
    }
    if (!(ict.kid in DEKS_MAP)) {
        throw new Error('DEK_NOT_FOUND');
    }
    const key = DEKS_MAP[ict.kid];
    return decryptAes(ict.c, ict.iv, key, ict.tag);
}
/**
 * Encrypt an object to the internal representation ciphertext.
 *
 * @param input object
 */
export function encrypt(input) {
    if (!DEKS || DEKS.length === 0) {
        throw new Error('DEK_ARRAY_IS_EMPTY');
    }
    const latestDek = DEKS[DEKS.length - 1];
    const kid = getKid(latestDek);
    let iv = crypto.randomBytes(16);
    iv = Buffer.from(iv).toString('base64');
    const e = encryptAes(input, iv, latestDek);
    const result = {
        v: CRYPTO_IMPL_VERSION,
        alg: CRYPTO_ALGORITHM,
        tag: e.tag,
        iv: iv,
        kid: kid,
        c: e.ciphertext,
    };
    return JSON.stringify(result);
}
/**
 * Decrypt an internal representation ciphertext to a string.
 *
 * @param internalCiphertext internal representation ciphertext
 */
export function decryptString(internalCiphertext) {
    return decrypt(internalCiphertext).toString('utf-8');
}
//# sourceMappingURL=crypto-aes.js.map