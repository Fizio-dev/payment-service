import { LoggerFactory } from '@republic-global/commons';
import { connect, } from 'amqp-connection-manager';
import {} from 'amqplib';
import { ChannelManager } from './channel-manager.js';
import {} from './config.js';
import { initializeTopology } from './topology.js';
import { requireInitialization, validateAlreadyInitialized } from './util.js';
export class MQSubscriber {
    opts;
    logger = LoggerFactory.getLogger('MQConsumer');
    connection;
    channelManager;
    initialized = false;
    constructor(opts) {
        this.opts = opts;
        this.connection = connect(opts.connectionConfig, opts.connectionOpts);
        this.connection.once('error', (error) => {
            this.logger.error(`Consumer connection error: ${error}`);
        });
        this.connection.once('close', (error) => {
            this.logger.error(`Consumer connection closed: ${error}`);
        });
        this.channelManager = new ChannelManager(this.connection, opts.channelOpts, 'subscribe');
    }
    async initialize() {
        validateAlreadyInitialized(this.initialized);
        await initializeTopology(this.connection, this.opts.topology);
        await this.channelManager.initialize();
        this.initialized = true;
    }
    async registerSubscriber(queueName, messageConsumer) {
        requireInitialization(this.initialized);
        this.logger.info(`Setting up a subscriber for queue ${queueName}`);
        const channel = this.channelManager.pickChannel();
        await channel.consume(queueName, async (message) => {
            try {
                const obj = JSON.parse(message.content.toString('utf-8'));
                this.logger.debug(`Received message from ${queueName} queue: ${JSON.stringify(obj)}`);
                await messageConsumer(obj);
                channel.ack(message);
            }
            catch (error) {
                this.handleError(message, error, channel);
            }
        });
    }
    async dispose() {
        this.logger.info('Disposing MQ Subscriber');
        await this.channelManager.close();
        await this.connection.close();
    }
    handleError(message, error, channel) {
        this.logger.error('Error while consuming message', error);
        this.logger.error('Sending nack for message', message);
        channel.nack(message, false, false);
    }
}
//# sourceMappingURL=mq-subscriber.js.map